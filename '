open! Base

type t = (Ast.t, string) Hashtbl.t

type var_t = Declared of string | Defined of string
[@@deriving compare, equal, sexp]

type vars_t = (string, var_t) Hashtbl.t
type scope_t = { vars : vars_t; parent : scope_t option }

let create_scope ?(parent : scope_t option = None) () =
  { vars = Hashtbl.create (module String); parent }

let create_map () = Hashtbl.create (module Ast)

let declare_var (scope : scope_t) (name : string) =
  Hashtbl.set scope.vars ~key:name ~data:(Declared name)

let define_var (scope : scope_t) (name : string) =
  Hashtbl.set scope.vars ~key:name ~data:(Defined name)

let rec statements (stmts : Ast.program_t) (scope : scope_t) (acc: t) : t = 
  match stmts with
  | [] -> create_map () 
  | stmt :: rest -> 
    statement stmt scope |> ignore;
    statements rest scope;

and statement (stmt : Ast.stmt_t) (scope : scope_t) (acc : t): t =
  match stmt with
| Ast.Block stmts -> statements stmts (create_scope ~parent:(Some scope) ())
| Ast.Function (_, _, body) -> statements body (create_scope ~parent:(Some scope) ())
| Ast.IfStmt (cond, branch, else_branch) -> (let x = expression cond scope in
    let x = statement branch scope in
    match else_branch with | Some else_branch -> statement else_branch scope | None -> x)
| Ast.WhileStmt (_, _) -> _
| Ast.ForStmt (_, _, _) -> _
| Ast.PrintStmt _ -> _
| Ast.ReturnStmt _ -> _
| Ast.VarStmt (_, _) -> _
| Ast.ExprStmt _ -> _) 

and expression (expr: Ast.t) (scope : scope_t) : t =
  match expr with
| Ast.Call (_, _, _) -> _
| Ast.Binary (_, _, _) -> _
| Ast.Logical (_, _, _) -> _
| Ast.Assign (_, _) -> _
| Ast.Grouping _ -> _
| Ast.Literal _ -> _
| Ast.Variable _ -> _
| Ast.Unary (_, _) -> _) with

let analyze_program (program : Ast.program_t) : t =
  statements program (create_scope ()) (create_map ())
